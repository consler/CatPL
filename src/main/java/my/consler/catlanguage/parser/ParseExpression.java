package my.consler.catlanguage.parser;

import my.consler.catlanguage.token.Token;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

public class ParseExpression // shunting yard algorithm generated by AI
{
    public static List<Token> parse(List<Token> expression_tokens)
    {
        Stack<Token> operator_stack = new Stack<>();
        List<Token> output = new ArrayList<>(); // Use List instead of Stack for output

        for (Token token : expression_tokens)
        {
            switch (token.getType())
            {
                case INTEGER -> output.add(token);
                case SYMBOL ->
                {
                    if (token.getValue().equals("("))
                    {
                        operator_stack.push(token);

                    }
                    else if (token.getValue().equals(")"))
                    {
                        while (!operator_stack.isEmpty() && !operator_stack.peek().getValue().equals("("))
                        {
                            output.add(operator_stack.pop());

                        }
                        operator_stack.pop(); // Pop the left parenthesis

                    }
                    else
                    {
                        operator_stack = addOperator(operator_stack, output, token);

                    }

                }

            }

        }

        // Pop all the operators from the stack
        while (!operator_stack.isEmpty())
        {
            Token top = operator_stack.pop();
            if (!top.getValue().equals("("))
            { // Ensure we don't add the left parenthesis
                output.add(top);

            }

        }

        return output; // Return the output in postfix notation

    }

    private static Stack<Token> addOperator(Stack<Token> operator_stack, List<Token> output, Token token)
    {
        while (!operator_stack.isEmpty() && precedence(operator_stack.peek()) >= precedence(token))
        {
            output.add(operator_stack.pop());

        }
        operator_stack.push(token);
        return operator_stack;

    }

    private static int precedence(Token token)
    {
        return switch (token.getValue())
        {
            case "+", "-" -> 1;
            case "*", "/" -> 2;
            default -> 0; // Non-operators have the lowest precedence
        };

    }

}
